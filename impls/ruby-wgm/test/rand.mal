;; rand.mal
;; Can I define a mini-prng? Let's see.

;; https://www.avrfreaks.net/forum/tiny-fast-prng has:
;; uint8_t rnd(void) {
;; static uint8_t s=0xaa,a=0;
;;        s^=s<<3;
;;        s^=s>>5;
;;        s^=a++>>2;
;;        return s;

;; Utilities
;; We need to be able to reverse a list, shift left and right bitwise, raise an
;; integer to the power of another integer, and calculate mod. Oh and inc an int.

;; Borrowed from trivial.mal
(def! inc
  (fn* [a]
    (+ a 1)))

;; rev
;; Pass it a list
;; Returns the list reversed
(def! rev
  (fn* (xs)
    (if (<= (count xs) 1)
        xs
        (concat
           (rev (rest xs))
           (list (first xs))))))

;; << and >> can be implemented with * and / respectively

(def! <<
  (fn* [n c]
    (if (= c 0)
        n
        (<< (* n 2) (- c 1)))))

(def! >>
  (fn* [n c]
    (if (= c 0)
        n
        (>> (/ n 2) (- c 1)))))

;; **
;; Pass it a number n, an exponent e, and, annoyingly, 1
;; Returns n to the e
(def! **
  (fn* [n e acc]
    (if (= e 0)
    acc
    (** n (- e 1) (* acc n)))))

;; mod
;; Give it a and n
;; Return a mod n
(def! mod
  (fn* [a n]
    (if (>= a n)
        (mod (- a n) n)
        a)))

;; ^ is somewhat tricker. Ahem.
;; (x ^ y) = (x | y) - (x & y), so we just need to implement | and &. Er.
;; Which is great and all, but if I convert to binary, there's no need, just
;; implement XOR directly, no need to piss about with AND and OR, it's the same.
;; In the absence of a clever numerical solution (which may not exist without
;; implementing some weird constraint thing I don't understand) there is no choice..

;; d2b
;; Pass it an integer and an empty list
;; Get back a list of 1's and 0's as binary representation of that integer
(def! d2b
  (fn* [dec li]
    (if (= 0 dec)
        li
        (if
          (= (/ dec 2) (/ (+ dec 1) 2))
          (d2b (>> dec 1) (cons 0 li))
          (d2b (>> dec 1) (cons 1 li))))))

;; b2d
;; Pass it 0 and a list of 1's and 0's representing an integer
;; Get back the integer represented by the binary
(def! b2d
  (fn* [dec li]
    (if (= (count li) 0)
        dec
        (b2d (+ dec (* (** 2 (- (count li) 1) 1) (first li))) (rest li)))))

;; mungebin
;; Pass it two lists of 1's and 0's representing two binary numbers and an empty list
;; Return a list representing the addition of each pair of numbers from each
;; list, counting from the end (so containing either 0, 1 or 2)
;; Assume the first number is larger (we will enforce this in the real xor
;; which will always call mungebin with a, b such that a > b)
;; This intermediate representation can then be processed elsewhere to implement
;; bitwise AND, OR and XOR.
(def! mungebin
  (fn* [li1 li2 res]
    (if (= (count li1) 0)
        res
        (if (= (count li2) 0)
            (mungebin () () (concat li1 res))
            (mungebin (rev (rest (rev li1))) (rev (rest (rev li2))) (cons (+ (first (rev li1)) (first (rev li2))) res))))))

;; xorfunc
;; Calculate xor for a bit via mungebin's intermediate representation
;; (I should add andfunc and orfunc in the same way, but not needed for this prng)
(def! xorfunc
  (fn* [a]
    (cond
      (= a 0) 0
      (= a 1) 1
      (= a 2) 0)))

;; xor
;; Finally, we can put all the above together and implement xor
;; Not quite a oneliner, because we promise mungebin that a is always > b, so
;; we test for that first and ensure this is going to be the case.
(def! xor
  (fn* [a b]
    (if (< a b)
        (xor b a)
        (b2d 0 (map xorfunc (mungebin (d2b a ()) (d2b b ()) ()))))))

;; A reminder of our PRNG algorithm:
;; NB - s is a uint8 so we need to mod 256 all results of operating on it.
;; static uint8_t s=0xaa,a=0;
;;        s^=s<<3;
;;        s^=s>>5;
;;        s^=a++>>2;
;;        return s;

;; Separating out the three steps of the algorithm for clarity
(def! rs1
  (fn* [s]
    (mod (xor s (<< s 3)) 256)))
(def! rs2
  (fn* [s]
    (mod (xor s (>> s 5)) 256)))
(def! rs3
  (fn* [s a]
    (mod (xor s (>> a 2)) 256)))

;; This gives us a pseudo-random number between 0 and 255
(def! rand256
  (let* [s (atom 170) a (atom 0)]
    (fn* []
      (do
        (swap! a inc)
        (swap! s rs1)
        (swap! s rs2)
        (swap! s rs3 @a)))))

;; rand n gives a pseudo-random number between 0 and n where n < 256
;; NB -- Very slow for small values of n.
(def! rand
  (fn* [n]
    (mod (rand256) n)))

;; rand2
;; Quicker than (rand 2), hopefully
(def! rand2
  (fn* []
     (let* [n (rand256)]
       (if (= (/ n 2) (/ (+ n 1) 2))
           1
           0))))
