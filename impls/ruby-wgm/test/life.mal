;; life.mal
;; If I can't implement Conway's Life, what's the point?

;; I have no idea how to do this in Lisp properly.
;; But it works, albeit slowly, and with caveats.

(load-file "test/rand.mal")

;; Borrowed from trivial.mal
(def! inc
  (fn* [a]
    (+ a 1)))

(def! dec
  (fn* [a]
    (- a 1)))

;; Borrowed from presentation.mal
(def! clear
  (fn* ()
    (str "[2J[;H")))

;; rand_cell
;; Randomly return either 0 or 1
(defmacro! rand_cell
  (fn* []
    '(rand2)))
;;  '(ruby-eval "rand(2)")))

;; make_line
;; Take an empty list and a length
;; Fill it with random cells
(def! make_line
  (fn* [line length]
      (if (< (count line) length)
        (make_line (cons (rand_cell) line) length)
        line)))

;; make_grid
;; Take an empty list, a height and a width
;; Call makeline height times, using width as length
(def! make_grid
  (fn* [grid w h]
    (if (< (count grid) h)
      (make_grid (cons (make_line () w) grid) w h)
      grid)))

;; print_cell
;; Take a cell
;; Return "O" if it is a 1, " " if 0
(def! print_cell
  (fn* [c]
    (if (= c 1)
        (str "O")
        (str " "))))

;; display_line
(def! display_line
  (fn* [line]
    (println (str (map print_cell line)))))

;; display_grid
(def! display_grid
  (fn* [grid]
    (map display_line grid)))

;; print_gen
(def! print_gen
  (fn* [gen grid]
    (do
      (println (clear))
      (println (str "Generation: " gen))
      (display_grid grid))))

;; get_cell
;; Take a grid and x, y coords
;; Return the value of the cell in that location
;; If error, we are out of bounds, so return 0
(def! get_cell
  (fn* [grid x y]
    (try*
      (nth (nth grid y) x)
    (catch* _ 0))))

;; get_neighbours
;; Take a grid and x, y coords
;; Count living neighbour cells and return that value
(def! get_neighbours
  (fn* [grid x y]
      (do
        (def! c 0)
        (if (= (get_cell grid (- x 1) (- y 1)) 1)
          (def! c (inc c)))
        (if (= (get_cell grid (- x 1) y) 1)
          (def! c (inc c)))
        (if (= (get_cell grid (- x 1) (+ y 1)) 1)
          (def! c (inc c)))
        (if (= (get_cell grid x (- y 1)) 1)
          (def! c (inc c)))
        (if (= (get_cell grid x (+ y 1)) 1)
          (def! c (inc c)))
        (if (= (get_cell grid (+ x 1) (- y 1)) 1)
          (def! c (inc c)))
        (if (= (get_cell grid (+ x 1) y) 1)
          (def! c (inc c)))
        (if (= (get_cell grid (+ x 1) (+ y 1)) 1)
          (def! c (inc c)))
        c)))

;; conrules
;; Take a grid and x y pos
;; Calculate whether the cell is alive or dead for next generation
;; Rules:
;; If dead: new cell is born if 3 neighbours
;; If alive: dies if < 2 neighbours or > 3 neighbours
(def! conrules
  (fn* [grid x y]
    (let* [n (get_neighbours grid x y)]
      (if (= (get_cell grid x y) 0)
          (if (= n 3)
              1
              0)
          (cond
            (< n 2) 0
            (> n 3) 0
            "else"  1)))))

;; conline
;; Take a grid, (), x and y
;; Return the new line of cells at the yth position of grid
(def! conline
  (fn* [grid newline x y]
    (if (= x -1)
        newline
        (do
          (conline grid (cons (conrules grid x y) newline) (dec x) y)))))

;; conway
;; Take a grid and calculate next life generation
;; Call with (), width and height
(def! conway
  (fn* [grid newgrid x y]
    (if (= y -1)
        newgrid
        (do
          (conway grid (cons (conline grid () x y) newgrid) x (dec y))))))

;; game_loop
;; Take generation number, the current grid and its dimensions
;; Keep calculating generations until 'q' is entered
(def! game_loop
  (fn* [gen grid w h]
    (do
      (print_gen gen grid)
      (if (not (= (readline "") "q"))
          (game_loop (+ gen 1) (conway grid () w h) w h)
          (println "Bye!")))))

;; life
;; Entry point: take w and h as parameters and start game_loop
;; with random cells generated by make_grid
(def! life
  (fn* [w h]
    (game_loop 1 (make_grid () w h) w h)))

(life 38 19)
